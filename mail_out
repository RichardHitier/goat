#! /usr/bin/perl -w

# Goat: Gentil Organisateur et Administrateur de Tournois
# Copyright (C) 2006-2007  Yves Rutschle
# 
# This program is free software; you can redistribute it
# and/or modify it under the terms of the GNU General Public
# License as published by the Free Software Foundation; either
# version 2 of the License, or (at your option) any later
# version.
# 
# This program is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
# PURPOSE.  See the GNU General Public License for more
# details.
# 
# The full text for the General Public License is here:
# http://www.gnu.org/licenses/gpl.html

use strict;

=head1 NAME

mail_out -- goat's e-mail sender

=head1 SYNOPSIS

mail_out [--mail-in-illegal <rcpt>,<file>]
         [--issue-challenge <black>,<white>,<handi>]
         [--remind-challenge <p1>,<p2>,<handi>,<final_date>]
         [--ask-results <p1>,<p2>]
         [--player-unknown <p1>]
         [--notify-schedule <b>,<w>,<handi>,<date>,<location>,<setter>]
         [--coming-up <b>,<w>,<handi>,<date>,<location>,<setter>]
         [--baddate <rcpt>,<date_str>]
         [--pastdate <rcpt>,<date_str>]
         [--give-results <p1>,<p2>,<reporter>,<winner>]
         [--badcolour <rcpt>,<colour_str>]
         [--attach <attachement>]

         [--no-send]

=head1 DESCRIPTION

Mail_out groups all of Goat's outgoing e-mail messages. This
concentrates all the e-mail management here, and allows for
easy translating or customising of outgoing messages.
(Translation support needs to be added though).

=cut

use Getopt::Long;
use Pod::Usage;
use Mail::Send;
use DateTime;  # package libdatetime-perl
use DateTime::Locale; # package libdatetime-locale-perl
use Template;
use POSIX;

# Check we have the right environment variables to find
# the modules, and add to @INC.
BEGIN {
    die "Environment variable GOAT_DIR and WORK_DIR must be defined\n" 
        if not defined $ENV{GOAT_DIR} or not defined $ENV{WORK_DIR};
    # This is necessary when called from .forward, in order
    # to find our .pm files.
    push @INC, $ENV{GOAT_DIR};
}

use GoatConfig;

my (
     $param_mail_in_illegal,
     $param_remind_challenge,
     $param_ask_result,
     $param_player_unknown,
     $param_issue_challenge,
     $param_notify_schedule,
     $param_coming_up,
     $param_baddate,
     $param_pastdate,
     $param_give_results,
     $param_badcolour,
     $param_attach,
     $no_send,
     $help,
 );

GetOptions(
    'mail-in-illegal=s'         => \$param_mail_in_illegal,
    'remind-challenge=s'        => \$param_remind_challenge,
    'ask-result=s'              => \$param_ask_result,
    'player-unknown=s'          => \$param_player_unknown,
    'issue-challenge=s'         => \$param_issue_challenge,
    'notify-schedule=s'         => \$param_notify_schedule,
    'coming-up=s'               => \$param_coming_up,
    'baddate=s'                 => \$param_baddate,
    'pastdate=s'                => \$param_pastdate,
    'give-results=s'            => \$param_give_results,
    'badcolour=s'               => \$param_badcolour,
    'attach=s'                  => \$param_attach,
    'no-send'                   => \$no_send,
    'help'                      => \$help,
) or die pod2usage();

die pod2usage(-verbose=>2) if defined $help;

my $LOGFILE = "$LOG_DIR/mail_out.log";

# record a line in a log file.
my ($logfile);
open $logfile, ">> $LOGFILE" or die "$LOGFILE: $!\n";
sub record {
    foreach (@_) {
        print $logfile (gmtime).": $_\n";
    }
}

my $tt = Template->new({ 
        INCLUDE_PATH => "$TEMPLATE_DIR",
    });


# Turn a UTC time_t into a localised timezoned string
sub utc2str {
    my $loc = DateTime::Locale->load($LOCALE);
    my $o = DateTime->from_epoch(epoch => $_[0], locale => $LOCALE, time_zone=>$TIMEZONE);
    my $date = $o->strftime("%A %d %B %Y %R");
}

# Makes a hash from a list
# $names: ref to list of names
# $vals: ref to list of vals
# Returns: hash of names => vals
sub make_hash {
    my ($names, $vals) = @_;
    my %h;

    map {$h{shift @$names} = $_ } @$vals;
    return %h;
}


# Send mail to one or several recipients:
# sendmail ['bob@foo.com', 'joe@bar.com'], $template, # \%data;
# if $param_attach is defined, collate the content of the
# file specified in $param_attach in the body of the email
sub sendmail {
    my ($r_to, $template, $r_data) = @_;

    my $body;
    $tt->process($template, $r_data, \$body) or die $tt->error;

    # Remove header lines
    $body =~ s/^(.*?)\n\n//s;
    my $hdrs = $1;
    my %hdr;
    foreach my $hdr (split /\n/, $hdrs) {
        $hdr =~ /(.*?): (.*)/;
        $hdr{$1} = lc $2;
    } 

    $r_to = [$r_to] unless ref $r_to;

    if (defined $param_attach) {
        if (open my $attch, "$param_attach") {
            $body .= $_ while (<$attch>);
        } else {
            record "Attach: $param_attach: $!";
        }
    }

    if ($no_send) {
        print "To: @$r_to\n$body";
        return;
    }

    # Happy debugger warning: this code is never tested by
    # the test suite, because we don't want it to *actually*
    # send e-mail. This means one must be extra careful when
    # editing it, and that it'll appear as not covered
    # during test (because, well, it isn't).
    my $msg = new Mail::Send Subject=>$hdr{subject}, To=>join ",", @$r_to;
    $msg->set('From' => $GOAT_ADDRESS);
    $msg->set('Return-path' => $GOAT_ADDRESS);
    $msg->set('X-Loop' => $GOAT_ADDRESS);
    $msg->set('Content-Type' => 'text/plain; charset=utf-8');
    my $fh = $msg->open or record "SMTP open: $!";
    print $fh $body;
    $fh->close;

    record("@$r_to: $hdr{subject}");
}

=head2 OPTIONS

=over 4

=item --mail-in-illegal <rcpt>,<command>

Called from mail_in on an illegal or unknwon command. 

=cut
if (defined $param_mail_in_illegal and
    $param_mail_in_illegal =~ /([^,]*),(.*)/) {

    my ($rcpt, $file) = ($1, $2);

    my $contents = `cat $file`;

    sendmail $rcpt, "badcmd.tt", { contents => $contents };
    exit 0;
}

=item --issue-challenge <black,white,handicap>

Sends players their pairing.

=cut

if (defined $param_issue_challenge) {
    my ($black, $white,$handi,$final_date) = split /\s*,\s*/, $param_issue_challenge;

    my $date = utc2str $final_date;
    my %data = make_hash( [qw/black white handi date/], [$black, $white, $handi, $date]);

    sendmail [$white, $black], "pairing.tt", \%data;
    exit 0;
}

=item --remind-challenge <black,white,handicap,final_date>

Remind players who haven't scheduled their game yet to do
so.

B<final_date> is UTC UNIX date.

=cut

if (defined $param_remind_challenge) {
    my ($black, $white,$handi,$final_date) = split /\s*,\s*/, $param_remind_challenge;

    my $date = utc2str $final_date;
    my %data = make_hash( [qw/black white handi date/], [$black, $white, $handi, $date]);

    sendmail [$white, $black], "organise.tt", \%data;
    exit 0;
}

=item --ask-results <black,white,date>

Ask players who had scheduled their game at I<date> that
they need to publish their results.

=cut

if (defined $param_ask_result) {
    my ($p1, $p2, $time) = split /\s*,\s*/, $param_ask_result;

    my $date = utc2str $time;

    my %data = make_hash( [qw/date/], [$date]);

    sendmail [$p1,$p2], "ask_result.tt", \%data;
    exit 0;

}

=item --player-unknown <address>

Notifies I<address> that that address is unknown. (Game
schedules and results must be sent from the e-mail address
that Goat knows about).

=cut

if (defined $param_player_unknown) {
    my ($p1) = $param_player_unknown;

    sendmail $p1, "unknown_address.tt";
    exit 0;
}

=item --notify-schedule <black,white,handicap,date,location,setter>

Notify players that I<setter> has scheduled the game to take
place on I<date> in I<location>

=cut

if (defined $param_notify_schedule) {

    my ($black,$white,$handi,$time,$location,$setter) = split /\s*,\s*/, $param_notify_schedule;

    my $date = utc2str $time;

    my %data = make_hash( [qw/ black white handi date location setter/ ],  [$black,$white,$handi,$date,$location,$setter]);
    sendmail [$black, $white], "scheduled.tt", \%data;
    exit 0;
}

=item --coming-up <black,white,handicap,date,location>

Notify players that their game is scheduled to take
place on I<date> (soon) in I<location>

=cut
if (defined $param_coming_up) {
    my ($black,$white,$handi,$time,$location) = split /\s*,\s*/, $param_coming_up;

    my $date = utc2str $time;

    my %data = make_hash([qw(black white handi date location)], [$black,$white,$handi,$date,$location]);
    sendmail [$black, $white], "game_reminder.tt", \%data;
    exit 0;
}

=item --baddate <rcpt,date>

Notify I<rcpt> that I<date> is invalid.

=cut

if (defined $param_baddate) {
    my ($rcpt,$date) = split /\s*,\s*/, $param_baddate;

    sendmail $rcpt, "baddate.tt", {date => "$date" };
    exit 0;
}

=item --pastdate <rcpt,date>

Notify I<rcpt> that I<date> is already past.

=cut

if (defined $param_pastdate) {
    my ($rcpt,$date) = split /\s*,\s*/, $param_pastdate;

    sendmail $rcpt, "pastdate.tt", {date => "$date" };
    exit 0;
}

=item --give-results <black,white,result,reporter>

Notify the players that I<reporter> has reported the result
of the game.

=cut

if (defined $param_give_results) {
    my ($black,$white,$res,$player) = split /\s*,\s*/, $param_give_results;

    my $winner = $res eq 'black' ? $black : $white;

    my %data = make_hash([qw(black white winner player)], 
                           [$black, $white, $winner, $player]);
    sendmail [$black, $white], "results.tt", \%data;
    exit 0;
}

=item --badcolour <rcpt,colour>

Notify I<rcpt> that I<colour> is not a valid color.

=cut

if (defined $param_badcolour) {
    my ($rcpt,$colour) = split /\s*,\s*/, $param_badcolour;

    sendmail $rcpt, "badcolour.tt", { colour => $colour };
    exit 0;
}


record "No action: ARGV=@ARGV";
